<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Java | springboot | springcloud | redis | mysql">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://github.com/chengxy-nds/chengxy-nds.github.io.git">
    <!--SEO-->

<meta name="keywords" content="延时队列,DelayQueue,Redis,RabbitMQ,时间轮" />


<meta name="description" content="
WX搜索【程序员内点事】，回复【666】妙不可言。

五一期间原计划是写两篇文章，看一本技术类书籍，结果这五天由于自律性过于差，禁不住各种诱惑，我连电脑都没打开过，计划完美宣告失败。所以在这能..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    6种 延时队列的实现方案，面试稳稳的 |
    
    Java | springboot | springcloud | redis | mysql
</title>

<link rel="alternate" href="/atom.xml" title="Java | springboot | springcloud | redis | mysql" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    /img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='程序员内点事'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                吃不了自律的苦，就要吃平庸的苦
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="https://github.com/chengxy-nds/chengxy-nds.github.io.git">
                        Java | springboot | springcloud | redis | mysql</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa fa-home"></i>
                                首页</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Java/"><i class="fa "></i>
                                Java</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Springboot/"><i class="fa "></i>
                                Springboot</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/分布式/"><i class="fa "></i>
                                分布式</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Redis/"><i class="fa "></i>
                                Redis</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/Mysql/"><i class="fa "></i>
                                Mysql</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="6种 延时队列的实现方案，面试稳稳的">
            
            6种 延时队列的实现方案，面试稳稳的
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/DelayQueue/" rel="tag">DelayQueue</a> <a class="tag-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a> <a class="tag-link" href="/tags/Redis/" rel="tag">Redis</a> <a class="tag-link" href="/tags/%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97/" rel="tag">延时队列</a> <a class="tag-link" href="/tags/%E6%97%B6%E9%97%B4%E8%BD%AE/" rel="tag">时间轮</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2020/05/13</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <blockquote>
<p>WX搜索【程序员内点事】，回复【666】妙不可言。</p>
</blockquote>
<p>五一期间原计划是写两篇文章，看一本技术类书籍，结果这五天由于自律性过于差，禁不住各种诱惑，我连电脑都没打开过，计划完美宣告失败。所以在这能看出和大佬之间的差距，人家没白没夜的更文，比你优秀的人比你更努力，难以望其项背，真是让我自愧不如。</p>
<p>知耻而后勇，这不逼着自己又学起来了，个人比较喜欢一些实践类的东西，既学习到知识又能让技术落地，能搞出个<code>demo</code>最好，本来不知道该分享什么主题，好在最近项目紧急招人中，而我有幸做了回面试官，就给大家整理分享一道面试题：“<strong>如何实现延时队列？</strong>”。</p>
<p>下边会介绍多种实现延时队列的思路，文末提供有几种实现方式的 <code>github</code>地址。其实哪种方式都没有绝对的好与坏，只是看把它用在什么业务场景中，技术这东西没有最好的只有最合适的。</p>
<h3 id="一、延时队列的应用"><a href="#一、延时队列的应用" class="headerlink" title="一、延时队列的应用"></a>一、延时队列的应用</h3><p>什么是延时队列？顾名思义：首先它要具有队列的特性，再给它附加一个延迟消费队列消息的功能，也就是说可以指定队列中的消息在哪个时间点被消费。</p>
<p>延时队列在项目中的应用还是比较多的，尤其像电商类平台：</p>
<p>1、订单成功后，在30分钟内没有支付，自动取消订单</p>
<p>2、外卖平台发送订餐通知，下单成功后60s给用户推送短信。</p>
<p>3、如果订单一直处于某一个未完结状态时，及时处理关单，并退还库存</p>
<p>4、淘宝新建商户一个月内还没上传商品信息，将冻结商铺等</p>
<p>。。。。</p>
<p>上边的这些场景都可以应用延时队列解决。</p>
<h3 id="二、延时队列的实现"><a href="#二、延时队列的实现" class="headerlink" title="二、延时队列的实现"></a>二、延时队列的实现</h3><p>我个人一直秉承的观点：工作上能用<code>JDK</code>自带<code>API</code>实现的功能，就不要轻易自己重复造轮子，或者引入三方中间件。一方面自己封装很容易出问题（大佬除外），再加上调试验证产生许多不必要的工作量；另一方面一旦接入三方的中间件就会让系统复杂度成倍的增加，维护成本也大大的增加。</p>
<h4 id="1、DelayQueue-延时队列"><a href="#1、DelayQueue-延时队列" class="headerlink" title="1、DelayQueue 延时队列"></a>1、DelayQueue 延时队列</h4><p><code>JDK</code> 中提供了一组实现延迟队列的<code>API</code>，位于<code>Java.util.concurrent</code>包下<code>DelayQueue</code>。</p>
<p><code>DelayQueue</code>是一个<code>BlockingQueue</code>（无界阻塞）队列，它本质就是封装了一个<code>PriorityQueue</code>（优先队列），<code>PriorityQueue</code>内部使用<code>完全二叉堆</code>（不知道的自行了解哈）来实现队列元素排序，我们在向<code>DelayQueue</code>队列中添加元素时，会给元素一个<code>Delay</code>（延迟时间）作为排序条件，队列中最小的元素会优先放在队首。队列中的元素只有到了<code>Delay</code>时间才允许从队列中取出。队列中可以放基本数据类型或自定义实体类，在存放基本数据类型时，优先队列中元素默认升序排列，自定义实体类就需要我们根据类属性值比较计算了。</p>
<p>先简单实现一下看看效果，添加三个<code>order</code>入队<code>DelayQueue</code>，分别设置订单在当前时间的<code>5秒</code>、<code>10秒</code>、<code>15秒</code>后取消。<br><img src="https://img-blog.csdnimg.cn/20200506141801287.png?#pic_center" alt="在这里插入图片描述"></p>
<p>要实现<code>DelayQueue</code>延时队列，队中元素要<code>implements</code> <code>Delayed</code> 接口，这哥接口里只有一个<code>getDelay</code>方法，用于设置延期时间。<code>Order</code>类中<code>compareTo</code>方法负责对队列中的元素进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonFormat</span>(locale = <span class="string">"zh"</span>, timezone = <span class="string">"GMT+8"</span>, pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String name, <span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = System.currentTimeMillis() + (time &gt; <span class="number">0</span> ? unit.toMillis(time) : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        Order Order = (Order) o;</span><br><span class="line">        <span class="keyword">long</span> diff = <span class="keyword">this</span>.time - Order.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DelayQueue</code>的<code>put</code>方法是线程安全的，因为<code>put</code>方法内部使用了<code>ReentrantLock</code>锁进行线程同步。<code>DelayQueue</code>还提供了两种出队的方法 <code>poll()</code> 和 <code>take()</code> ， <code>poll()</code> 为非阻塞获取，没有到期的元素直接返回null；<code>take()</code> 阻塞方式获取，没有到期的元素线程将会等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Order Order1 = <span class="keyword">new</span> Order(<span class="string">"Order1"</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        Order Order2 = <span class="keyword">new</span> Order(<span class="string">"Order2"</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        Order Order3 = <span class="keyword">new</span> Order(<span class="string">"Order3"</span>, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">        DelayQueue&lt;Order&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        delayQueue.put(Order1);</span><br><span class="line">        delayQueue.put(Order2);</span><br><span class="line">        delayQueue.put(Order3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"订单延迟队列开始时间:"</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">while</span> (delayQueue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 取队列头部元素是否过期</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Order task = delayQueue.poll();</span><br><span class="line">            <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.format(<span class="string">"订单:&#123;%s&#125;被取消, 取消时间:&#123;%s&#125;\n"</span>, task.name, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边只是简单的实现入队与出队的操作，实际开发中会有专门的线程，负责消息的入队与消费。</p>
<p>执行后看到结果如下，<code>Order1</code>、<code>Order2</code>、<code>Order3</code> 分别在 <code>5秒</code>、<code>10秒</code>、<code>15秒</code>后被执行，至此就用<code>DelayQueue</code>实现了延时队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">订单延迟队列开始时间:<span class="number">2020</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">59</span>:<span class="number">09</span></span><br><span class="line">订单:&#123;Order1&#125;被取消, 取消时间:&#123;<span class="number">2020</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">59</span>:<span class="number">14</span>&#125;</span><br><span class="line">订单:&#123;Order2&#125;被取消, 取消时间:&#123;<span class="number">2020</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">59</span>:<span class="number">19</span>&#125;</span><br><span class="line">订单:&#123;Order3&#125;被取消, 取消时间:&#123;<span class="number">2020</span>-<span class="number">05</span>-<span class="number">06</span> <span class="number">14</span>:<span class="number">59</span>:<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Quartz-定时任务"><a href="#2、Quartz-定时任务" class="headerlink" title="2、Quartz 定时任务"></a>2、Quartz 定时任务</h4><p><code>Quartz</code>一款非常经典任务调度框架，在<code>Redis</code>、<code>RabbitMQ</code>还未广泛应用时，超时未支付取消订单功能都是由定时任务实现的。定时任务它有一定的周期性，可能很多单子已经超时，但还没到达触发执行的时间点，那么就会造成订单处理的不够及时。</p>
<p>引入<code>quartz</code>框架依赖包</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在启动类中使用<code>@EnableScheduling</code>注解开启定时任务功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayqueueApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DelayqueueApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写一个定时任务，每个5秒执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每隔五秒</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ? "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是定时任务！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3、Redis-sorted-set"><a href="#3、Redis-sorted-set" class="headerlink" title="3、Redis sorted set"></a>3、Redis sorted set</h4><p><code>Redis</code>的数据结构<code>Zset</code>，同样可以实现延迟队列的效果，主要利用它的<code>score</code>属性，<code>redis</code>通过<code>score</code>来为集合中的成员进行从小到大的排序。<br><img src="https://img-blog.csdnimg.cn/20200507130701854.png#pic_center" alt="在这里插入图片描述"><br>通过<code>zadd</code>命令向队列<code>delayqueue</code> 中添加元素，并设置<code>score</code>值表示元素过期的时间；向<code>delayqueue</code> 添加三个<code>order1</code>、<code>order2</code>、<code>order3</code>，分别是<code>10秒</code>、<code>20秒</code>、<code>30秒</code>后过期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd delayqueue <span class="number">3</span> order3</span><br></pre></td></tr></table></figure>
<p>消费端轮询队列<code>delayqueue</code>， 将元素排序后取最小时间与当前时间比对，如小于当前时间代表已经过期移除<code>key</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pollOrderQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Set&lt;Tuple&gt; set = jedis.zrangeWithScores(DELAY_QUEUE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        String value = ((Tuple) set.toArray()[<span class="number">0</span>]).getElement();</span><br><span class="line">        <span class="keyword">int</span> score = (<span class="keyword">int</span>) ((Tuple) set.toArray()[<span class="number">0</span>]).getScore();</span><br><span class="line">        </span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        <span class="keyword">int</span> nowSecond = (<span class="keyword">int</span>) (cal.getTimeInMillis() / <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (nowSecond &gt;= score) &#123;</span><br><span class="line">            jedis.zrem(DELAY_QUEUE, value);</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> Date()) + <span class="string">" removed key:"</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (jedis.zcard(DELAY_QUEUE) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(sdf.format(<span class="keyword">new</span> Date()) + <span class="string">" zset empty "</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到执行结果符合预期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">09</span> add finished.</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">19</span> removed key:order1</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">29</span> removed key:order2</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">39</span> removed key:order3</span><br><span class="line"><span class="number">2020</span>-<span class="number">05</span>-<span class="number">07</span> <span class="number">13</span>:<span class="number">24</span>:<span class="number">39</span> zset empty</span><br></pre></td></tr></table></figure>

<h4 id="4、Redis-过期回调"><a href="#4、Redis-过期回调" class="headerlink" title="4、Redis 过期回调"></a>4、Redis 过期回调</h4><p><code>Redis</code> 的<code>key</code>过期回调事件，也能达到延迟队列的效果，简单来说我们开启监听key是否过期的事件，一旦key过期会触发一个callback事件。</p>
<p>修改<code>redis.conf</code>文件开启<code>notify-keyspace-events Ex</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex</span><br></pre></td></tr></table></figure>

<p><code>Redis</code>监听配置，注入Bean <code>RedisMessageListenerContainer</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisListenerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RedisMessageListenerContainer container = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">        container.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Redis过期回调监听方法，必须继承<code>KeyExpirationEventMessageListener</code> ，有点类似于MQ的消息监听。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpirationListener</span> <span class="keyword">extends</span> <span class="title">KeyExpirationEventMessageListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisKeyExpirationListener</span><span class="params">(RedisMessageListenerContainer listenerContainer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(listenerContainer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        String expiredKey = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"监听到key："</span> + expiredKey + <span class="string">"已过期"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这代码就编写完成，非常的简单，接下来测试一下效果，在<code>redis-cli</code>客户端添加一个<code>key</code> 并给定<code>3s</code>的过期时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set xiaofu <span class="number">123</span> ex <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>在控制台成功监听到了这个过期的<code>key</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监听到过期的key为：xiaofu</span><br></pre></td></tr></table></figure>

<h4 id="5、RabbitMQ-延时队列"><a href="#5、RabbitMQ-延时队列" class="headerlink" title="5、RabbitMQ 延时队列"></a>5、RabbitMQ 延时队列</h4><p>利用 <code>RabbitMQ</code> 做延时队列是比较常见的一种方式，而实际上<code>RabbitMQ</code> 自身并没有直接支持提供延迟队列功能，而是通过 <code>RabbitMQ</code> 消息队列的 <code>TTL</code>和 <code>DXL</code>这两个属性间接实现的。</p>
<p>先来认识一下 <code>TTL</code>和 <code>DXL</code>两个概念：</p>
<p><code>Time To Live</code>(<code>TTL</code>) ：</p>
<p><code>TTL</code> 顾名思义：指的是消息的存活时间，<code>RabbitMQ</code>可以通过<code>x-message-tt</code>参数来设置指定<code>Queue</code>（队列）和 <code>Message</code>（消息）上消息的存活时间，它的值是一个非负整数，单位为微秒。</p>
<p><code>RabbitMQ</code> 可以从两种维度设置消息过期时间，分别是<code>队列</code>和<code>消息本身</code></p>
<ul>
<li>设置队列过期时间，那么队列中所有消息都具有相同的过期时间。 </li>
<li>设置消息过期时间，对队列中的某一条消息设置过期时间，每条消息<code>TTL</code>都可以不同。</li>
</ul>
<p>如果同时设置队列和队列中消息的<code>TTL</code>，则<code>TTL</code>值以两者中较小的值为准。而队列中的消息存在队列中的时间，一旦超过<code>TTL</code>过期时间则成为<code>Dead Letter</code>（死信）。</p>
<p><code>Dead Letter Exchanges</code>（<code>DLX</code>）</p>
<p><code>DLX</code>即死信交换机，绑定在死信交换机上的即死信队列。<code>RabbitMQ</code>的 <code>Queue</code>（队列）可以配置两个参数<code>x-dead-letter-exchange</code> 和 <code>x-dead-letter-routing-key</code>（可选），一旦队列内出现了<code>Dead Letter</code>（死信），则按照这两个参数可以将消息重新路由到另一个<code>Exchange</code>（交换机），让消息重新被消费。</p>
<p><code>x-dead-letter-exchange</code>：队列中出现<code>Dead Letter</code>后将<code>Dead Letter</code>重新路由转发到指定 <code>exchange</code>（交换机）。</p>
<p><code>x-dead-letter-routing-key</code>：指定<code>routing-key</code>发送，一般为要指定转发的队列。</p>
<p>队列出现<code>Dead Letter</code>的情况有：</p>
<ul>
<li>消息或者队列的<code>TTL</code>过期 </li>
<li>队列达到最大长度 </li>
<li>消息被消费端拒绝（basic.reject or basic.nack）</li>
</ul>
<p>下边结合一张图看看如何实现超30分钟未支付关单功能，我们将订单消息A0001发送到延迟队列<code>order.delay.queue</code>，并设置<code>x-message-tt</code>消息存活时间为30分钟，当到达30分钟后订单消息A0001成为了<code>Dead Letter</code>（死信），延迟队列检测到有死信，通过配置<code>x-dead-letter-exchange</code>，将死信重新转发到能正常消费的关单队列，直接监听关单队列处理关单逻辑即可。<br><img src="https://img-blog.csdnimg.cn/2020050710594667.png?#pic_center" alt="在这里插入图片描述"></p>
<p>发送消息时指定消息延迟的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String delayTimes)</span> </span>&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">"order.pay.exchange"</span>, <span class="string">"order.pay.queue"</span>,<span class="string">"大家好我是延迟数据"</span>, message -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置延迟毫秒值</span></span><br><span class="line">            message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置延迟队列出现死信后的转发规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"order.delay.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">getMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(RabbitConstant.DEAD_LETTER_QUEUE)</span><br><span class="line">                <span class="comment">// 配置到期后转发的交换</span></span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-exchange"</span>, <span class="string">"order.close.exchange"</span>)</span><br><span class="line">                <span class="comment">// 配置到期后转发的路由键</span></span><br><span class="line">                .withArgument(<span class="string">"x-dead-letter-routing-key"</span>, <span class="string">"order.close.queue"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、时间轮"><a href="#6、时间轮" class="headerlink" title="6、时间轮"></a>6、时间轮</h4><p>前边几种延时队列的实现方法相对简单，比较容易理解，时间轮算法就稍微有点抽象了。<code>kafka</code>、<code>netty</code>都有基于时间轮算法实现延时队列，下边主要实践<code>Netty</code>的延时队列讲一下时间轮是什么原理。</p>
<p>先来看一张时间轮的原理图，解读一下时间轮的几个基本概念<br><img src="https://img-blog.csdnimg.cn/20200507145532281.png#pic_center" alt="在这里插入图片描述"><br><code>wheel</code> ：时间轮，图中的圆盘可以看作是钟表的刻度。比如一圈<code>round</code> 长度为<code>24秒</code>，刻度数为 <code>8</code>，那么每一个刻度表示 <code>3秒</code>。那么时间精度就是  <code>3秒</code>。时间长度 / 刻度数值越大，精度越大。</p>
<p>当添加一个定时、延时<code>任务A</code>，假如会延迟<code>25秒</code>后才会执行，可时间轮一圈<code>round</code> 的长度才<code>24秒</code>，那么此时会根据时间轮长度和刻度得到一个圈数 <code>round</code>和对应的指针位置 <code>index</code>，也是就<code>任务A</code>会绕一圈指向<code>0格子</code>上，此时时间轮会记录该任务的<code>round</code>和 <code>index</code>信息。当round=0，index=0 ，指针指向<code>0格子</code>  <code>任务A</code>并不会执行，因为 round=0不满足要求。</p>
<p>所以每一个格子代表的是一些时间，比如<code>1秒</code>和<code>25秒</code> 都会指向0格子上，而任务则放在每个格子对应的链表中，这点和<code>HashMap</code>的数据有些类似。</p>
<p><code>Netty</code>构建延时队列主要用<code>HashedWheelTimer</code>，<code>HashedWheelTimer</code>底层数据结构依然是使用<code>DelayedQueue</code>，只是采用时间轮的算法来实现。</p>
<p>下面我们用<code>Netty</code> 简单实现延时队列，<code>HashedWheelTimer</code>构造函数比较多，解释一下各参数的含义。</p>
<ul>
<li><code>ThreadFactory</code> ：表示用于生成工作线程，一般采用线程池；</li>
<li><code>tickDuration</code>和<code>unit</code>：每格的时间间隔，默认100ms；</li>
<li><code>ticksPerWheel</code>：一圈下来有几格，默认512，而如果传入数值的不是2的N次方，则会调整为大于等于该参数的一个2的N次方数值，有利于优化<code>hash</code>值的计算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory, <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>TimerTask</code>：一个定时任务的实现接口，其中run方法包装了定时任务的逻辑。</li>
<li><code>Timeout</code>：一个定时任务提交到<code>Timer</code>之后返回的句柄，通过这个句柄外部可以取消这个定时任务，并对定时任务的状态进行一些基本的判断。</li>
<li><code>Timer</code>：是<code>HashedWheelTimer</code>实现的父接口，仅定义了如何提交定时任务和如何停止整个定时机制。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyDelayQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Timer timer = <span class="keyword">new</span> HashedWheelTimer(Executors.defaultThreadFactory(), <span class="number">5</span>, TimeUnit.SECONDS, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时任务</span></span><br><span class="line">        TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"order1  5s 后执行 "</span>);</span><br><span class="line">                timer.newTimeout(<span class="keyword">this</span>, <span class="number">5</span>, TimeUnit.SECONDS);<span class="comment">//结束时候再次注册</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.newTimeout(task1, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"order2  10s 后执行"</span>);</span><br><span class="line">                timer.newTimeout(<span class="keyword">this</span>, <span class="number">10</span>, TimeUnit.SECONDS);<span class="comment">//结束时候再注册</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        timer.newTimeout(task2, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延迟任务</span></span><br><span class="line">        timer.newTimeout(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"order3  15s 后执行一次"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从执行的结果看，<code>order3</code>、<code>order3</code>延时任务只执行了一次，而<code>order2</code>、<code>order1</code>为定时任务，按照不同的周期重复执行。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order1  <span class="number">5</span>s 后执行 </span><br><span class="line">order2  <span class="number">10</span>s 后执行</span><br><span class="line">order3  <span class="number">15</span>s 后执行一次</span><br><span class="line">order1  <span class="number">5</span>s 后执行 </span><br><span class="line">order2  <span class="number">10</span>s 后执行</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了让大家更容易理解，上边的代码写的都比较简单粗糙，几种实现方式的<code>demo</code>已经都提交到<code>github</code> 地址：<code>https://github.com/chengxy-nds/delayqueue</code>，感兴趣的小伙伴可以下载跑一跑。</p>
<p>这篇文章肝了挺长时间，写作一点也不比上班干活轻松，查证资料反复验证demo的可行性，搭建各种<code>RabbitMQ</code>、<code>Redis</code>环境，只想说我太难了！</p>
<p>可能写的有不够完善的地方，如哪里有错误或者不明了的，欢迎大家踊跃指正！！！</p>
<blockquote>
<p>整理了几百本各类技术电子书和视频资料 ，<code>嘘~</code>，<code>免费</code> 送，公号内回复【<code>666</code>】自行领取。和小伙伴们建了一个<code>技术交流群</code>，一起探讨技术、分享技术资料，旨在共同学习进步，感兴趣就入我们吧！</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8yLzQvMTcwMGU0Mjk1MDQzMjQ0Yg?x-oss-process=image/format,png" alt=""></p>

    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="/img/支付宝支付码.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="/img/微信支付码.png"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        赞赏是不耍流氓的鼓励
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            转载请注明出处
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/2020/05/12/%E4%B8%80%E5%8F%A3%E6%B0%94%E8%AF%B4%E5%87%BA%206%E7%A7%8D%EF%BC%8C@Transactional%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/" class="next-post btn btn-default" title='一口气说出 6种，@Transactional注解的失效场景'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            一口气说出 6种，@Transactional注解的失效场景</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
    appKey: 'erIpQac4azoCmgfBB7Dl9maa',
    placeholder: '说点什么吧',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '20',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>



                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            文章目录
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、延时队列的应用"><span class="toc-text">一、延时队列的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、延时队列的实现"><span class="toc-text">二、延时队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、DelayQueue-延时队列"><span class="toc-text">1、DelayQueue 延时队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、Quartz-定时任务"><span class="toc-text">2、Quartz 定时任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、Redis-sorted-set"><span class="toc-text">3、Redis sorted set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、Redis-过期回调"><span class="toc-text">4、Redis 过期回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、RabbitMQ-延时队列"><span class="toc-text">5、RabbitMQ 延时队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、时间轮"><span class="toc-text">6、时间轮</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2020
                    
                </span> |
                <span>
                   <a href="www.chengxy-nds.top/" class="copyright-links" target="_blank" rel="nofollow">chengxy-nds.top</a> 版权所有
                </span> |
                <span>

                </span>
            </div>
        </div>
    </div>
</div>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>